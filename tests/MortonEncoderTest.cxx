#include <FastBVH/MortonCurve.h>

#include <gtest/gtest.h>

using namespace FastBVH;

TEST(MortonEncoderTest, Encode32) {

  MortonEncoder<4> encoder;

  //   0  1  0  0  1  0  0  0  0  0
  //    1  0  0  0  1  1  0  0  0  0
  //     0  0  1  1  0  0  0  0  0  1
  // --------------------------------
  // 00010100001001110010000000000001

  auto result = encoder(0b01'0010'0000, 0b10'0011'0000, 0b00'1100'0001);

  EXPECT_EQ(result, 0b00010100001001110010000000000001);
}

TEST(MortonEncoderTest, Encode64) {

  MortonEncoder<8> encoder;

  U64 x = 0b10010'00001000'01000010;
  U64 y = 0b01000'00010010'00000100;
  U64 z = 0b10100'01000000'00100001;

  //  1  0  0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0  1  0
  //   0  1  0  0  0  0  0  0  1  0  0  1  0  0  0  0  0  0  1  0  0
  //    1  0  1  0  0  0  1  0  0  0  0  0  0  0  0  1  0  0  0  0  1
  // ----------------------------------------------------------------
  // 0101010001100000000001000010100000010000000100001000000010100001 = 0x54600428101080A1

  auto result = encoder(x, y, z);

  EXPECT_EQ(result, 0x54600428101080A1);
}

#ifndef FASTBVH_NO_INT128

TEST(MortonEncoderTest, Encode128) {

  MortonEncoder<16> encoder;

  U128 x = 0b00'00100010'01001000'00000100'00101100'00010010ULL;
  U128 y = 0b10'00001000'00100000'01100000'00000000'01000100ULL;
  U128 z = 0b01'00000010'00000010'00000010'00000010'00000000ULL;

  //   0  0  0  0  1  0  0  0  1  0  0  1  0  0  1  0  0  0  0  0  0  0  0  1  0  0  0  0  1  0  1  1  0  0  0  0  0  1  0  0  1  0
  //    1  0  0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  0  0  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  1  0  0
  //     0  1  0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0
  // --------------------------------------------------------------------------------------------------------------------------------
  // 00010001000000100000010000101000000100010000100000001000000010010000000100001000000000100000100100001000000010000100000010100000
  //
  // In hex: 0x110204281108080901080209080840A0
  //
  //   High: 0x1102042811080809
  //    Low: 0x01080209080840A0

  auto result = encoder(x, y, z);

  auto equal = result == literal128U(0x1102042811080809, 0x01080209080840A0);

  EXPECT_EQ(equal, true);

  //EXPECT_EQ(result, literal128U(0x1102042811080809, 0x01080209080840A0));
}

#endif // FASTBVH_NO_INT128
